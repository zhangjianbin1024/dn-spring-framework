<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"

       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
	   http://www.springframework.org/schema/aop/spring-aop-4.3.xsd">


    <description>Spring aop 配置</description>


    <!-- service 实例化 -->
    <bean id="myservice" class="com.dn.spring.service.MyServiceImpl"></bean>
    <!--<bean id="myservice2" class="com.dn.spring.service.MyServiceImp2"></bean>-->

    <!--切面 bean-->
    <bean id="myaspectj" class="com.dn.spring.aop.AopAspectj"></bean>

    <!-- 方法通过aop动态注入其它bean中 -->
    <bean id="myintroduction" class="com.dn.spring.aop.IntroductionClass"></bean>

    <!--自己定义的通知必须要实现 MethodInterceptor-->
    <bean id="myInterceptor" class="com.dn.spring.interceptor.MyInterceptor"></bean>

    <!--
        <aop:pointcut>：用来定义切入点，该切入点可以重用；
         <aop:advisor>：用来定义只有一个通知和一个切入点的切面；
         <aop:aspect>：用来定义切面，该切面可以包含多个切入点和通知，而且标签内部的通知和切入点定义是无序的；
         和advisor的区别就在此，advisor只包含一个通知和一个切入点。

         强制使用CGLIB代理需要将 <aop:config> 的 proxy-target-class 属性设为true:
         proxy-target-class="true"
         proxy-target-class="false"
     -->
    <aop:config proxy-target-class="true">
        <!--自定义切面 myInterceptor-->
        <!--<aop:advisor advice-ref="myInterceptor" pointcut="execution(public * com.dn.spring.service..*.*(..))"-->
                     <!--order="1"/>-->
        <!--
            <aop:pointcut> 在此处定义的pointcut是全局的 pointcut 可以供所有的 aspect 使用
            id:表示这个pointcut的名称，以方便使用
        -->

        <!--
             <aop:aspect>表示定义一个切面类(这需要Spring初始化加入其管理)
             id:切面类的名称，
             ref:引用哪个bean(需要使用<bean>标签初始化)
         -->
        <aop:aspect id="txAspect" ref="myaspectj" order="2">

            <!-- 通过aop动态注入方法 -->
            <!--
                切面中的该标签 declare-parents，是切面中的introduction引入，该标签的功能可以做到对target目标类的扩展，
                相当于往target目标类中增加了方法。这样做可以对目标类进行功能扩展，便于后期维护，满足开闭原则
             -->
            <!--<aop:declare-parents types-matching="com.dn.spring.service.MyServiceImpl"-->
                                 <!--implement-interface="com.dn.spring.aop.IntroductionIntf"-->
                                 <!--delegate-ref="myintroduction"/>-->
            <!--
                 <aop:pointcut> 在此处定义的 pointcut 是全局的 pointcut 只供当前的 aspect 使用
                 id:表示这个 pointcut 的名称，以方便使用
             -->
            <aop:pointcut id="myMethod2" expression="execution(public * com.dn.spring.service..*.*(..))"/>

            <!--
                定义 advice时 的参数
                method:切面逻辑的方法名称(切面类中的方法名)
                pointcut-ref：表示引用哪个 pointcut (要求已经在上面定义好了)
                pointcut：定义一个pointcut
            -->

            <!--method标签定义的方法执行顺序与位置有关系-->
            <aop:before method="before" pointcut-ref="myMethod2"/>
            <aop:after-returning method="afterReturning" pointcut-ref="myMethod2"/>
            <aop:after method="after" pointcut-ref="myMethod2"/>
            <aop:after-throwing method="afterthrowing" pointcut-ref="myMethod2"/>
            <aop:around method="around" pointcut-ref="myMethod2"/>

            <!--<aop:before method="before" pointcut="execution(public * com.dongnao.jack.service..*.*(..))"/>-->
            <!--<aop:after method="after" pointcut-ref="myMethod2"/>-->
        </aop:aspect>
    </aop:config>

    <!--aop 注解的支持-->
    <!--<aop:aspectj-autoproxy/>-->


    <!--
     Spring AOP部分使用JDK动态代理或者CGLIB来为目标对象创建代理。（建议尽量使用JDK的动态代理）
     如果被代理的目标对象实现了至少一个接口，则会使用JDK动态代理。
     所有该目标类型实现的接口都将被代理。若该目标对象没有实现任何接口，则创建一个CGLIB代理

    如果你希望强制使用CGLIB代理，（例如：希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下问题:
    1. 无法通知（advise）Final 方法，因为他们不能被覆写。
    2. 你需要将CGLIB 二进制发行包放在classpath下面，与之相较JDK本身就提供了动态代理
    强制使用CGLIB代理需要将 <aop:config> 的 proxy-target-class 属性设为true:

    JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。

    CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB是高效的代码生成包，
    底层是依靠ASM（开源的java字节码编辑类库）操作字节码实现的，性能比JDK强。

    proxy-target-class="true" 与proxy-target-class="false"的区别：
    proxy-target-class属性值决定是基于接口的还是基于类的代理被创建。
    1.如果proxy-target-class 属性值被设置为true，那么基于类的代理将起作用（这时需要cglib库）。
    2.如果proxy-target-class属值被设置为false或者这个属性被省略，那么标准的JDK 基于接口的代理
     -->
    <!--<aop:aspectj-autoproxy proxy-target-class="true"/>-->

</beans>